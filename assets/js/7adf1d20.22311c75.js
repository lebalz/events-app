"use strict";(self.webpackChunkevents_app=self.webpackChunkevents_app||[]).push([["9117"],{88258:function(e,s,t){t.r(s),t.d(s,{frontMatter:()=>i,toc:()=>d,default:()=>h,metadata:()=>n,assets:()=>c,contentTitle:()=>o});var n=JSON.parse('{"id":"dev/events-api/external_data_sync_","title":"Chapter 6: External Data Sync","description":"Welcome back! So far, we\'ve explored how our events-api handles incoming requests from the \\"outside world\\" \u2013 think of a user clicking a button in a web application. We saw how Express.js receives the request (API Web Server (Express.js)), middleware secures it (Access Control (Authentication & Authorization)), Controllers direct it (Request Handlers (Controllers)), and Models and Prisma interact with the database (Data Logic (Models), Database ORM (Prisma)). This is the core flow for user-initiated actions.","source":"@site/docs/10-dev/events-api/06_external_data_sync_.md","sourceDirName":"10-dev/events-api","slug":"/dev/events-api/external_data_sync_","permalink":"/docs/dev/events-api/external_data_sync_","draft":false,"unlisted":false,"editUrl":"https://github.com/lebalz/events-app/edit/main/10-dev/events-api/06_external_data_sync_.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"page_id":"b7aaf889-c941-4317-ba62-6aa3e026c1eb"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 5: Request Handlers (Controllers)","permalink":"/docs/dev/events-api/request_handlers__controllers__"},"next":{"title":"Chapter 7: Background Task Runner (Bree)","permalink":"/docs/dev/events-api/background_task_runner__bree__"}}'),a=t(85893),r=t(50065);let i={page_id:"b7aaf889-c941-4317-ba62-6aa3e026c1eb"},o="Chapter 6: External Data Sync",c={},d=[{value:"The Automated Courier Service",id:"the-automated-courier-service",level:2},{value:"Our Use Case: Getting Untis Timetables into the Database",id:"our-use-case-getting-untis-timetables-into-the-database",level:2},{value:"How External Data Sync Works (Not via API Requests)",id:"how-external-data-sync-works-not-via-api-requests",level:2},{value:"Under the Hood: The Sync Process",id:"under-the-hood-the-sync-process",level:2},{value:"Step 1: Fetching Data (<code>src\\services\\fetchUntis.ts</code>)",id:"step-1-fetching-data-srcservicesfetchuntists",level:3},{value:"Step 2: Syncing Data to DB (<code>src\\services\\syncUntis2DB.ts</code>)",id:"step-2-syncing-data-to-db-srcservicessyncuntis2dbts",level:3},{value:"The Flow of External Data Sync",id:"the-flow-of-external-data-sync",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){let s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"chapter-6-external-data-sync",children:"Chapter 6: External Data Sync"})}),"\n",(0,a.jsxs)(s.p,{children:["Welcome back! So far, we've explored how our ",(0,a.jsx)(s.code,{children:"events-api"}),' handles incoming requests from the "outside world" \u2013 think of a user clicking a button in a web application. We saw how Express.js receives the request (',(0,a.jsx)(s.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),"), middleware secures it (",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/access_control__authentication___authorization__",children:"Access Control (Authentication & Authorization)"}),"), Controllers direct it (",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/request_handlers__controllers__",children:"Request Handlers (Controllers)"}),"), and Models and Prisma interact with the database (",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Data Logic (Models)"}),", ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Database ORM (Prisma)"}),"). This is the core flow for user-initiated actions."]}),"\n",(0,a.jsx)(s.p,{children:"But what about data that doesn't come from a user clicking a button? Our application needs to know about things like accurate class timetables, teacher lists, and potentially old event data stored in other systems. This information changes over time and needs to be updated in our database somehow. It would be impractical (and prone to errors) for a person to manually enter or update all this every time it changes."}),"\n",(0,a.jsx)(s.h2,{id:"the-automated-courier-service",children:"The Automated Courier Service"}),"\n",(0,a.jsx)(s.p,{children:"Imagine our application's database is a library's catalog. User requests are like librarians looking up specific books or adding new ones based on patron requests."}),"\n",(0,a.jsxs)(s.p,{children:["External Data Sync is like having an ",(0,a.jsx)(s.strong,{children:"automated courier service"})," that regularly visits other libraries (external systems like the Untis school system or old file archives), collects updated lists of books, new arrival lists, or corrections to existing entries, and brings them back to our library to update our catalog."]}),"\n",(0,a.jsx)(s.p,{children:"This process runs independently of individual user requests. Its main goals are:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Fetch Data:"})," Retrieve information from outside sources."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Process Data:"})," Clean, format, and maybe transform the data to fit our database structure."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Sync Database:"})," Add new records, update existing ones, or mark old ones as inactive based on the external data, using tools like ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["In our ",(0,a.jsx)(s.code,{children:"events-api"})," project, this external data comes mainly from:"]}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Untis:"})," A school administration system containing timetables, teachers, classes, etc. This data needs to be synced regularly."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Legacy Import Files:"})," Old CSV or Excel files containing historical event data that needs to be imported once (or occasionally updated if the source files change)."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"our-use-case-getting-untis-timetables-into-the-database",children:"Our Use Case: Getting Untis Timetables into the Database"}),"\n",(0,a.jsxs)(s.p,{children:["Let's focus on syncing data from the Untis system. The ",(0,a.jsx)(s.code,{children:"events-api"})," needs to show accurate information about classes, teachers, and which lessons are happening, especially because events might affect teaching periods. This data is managed in Untis."]}),"\n",(0,a.jsxs)(s.p,{children:["So, our use case for External Data Sync is: ",(0,a.jsxs)(s.strong,{children:["Synchronize timetable, class, and teacher data from the Untis system into the ",(0,a.jsx)(s.code,{children:"events-api"})," database."]})]}),"\n",(0,a.jsx)(s.p,{children:"This needs to happen automatically, perhaps daily or weekly."}),"\n",(0,a.jsx)(s.h2,{id:"how-external-data-sync-works-not-via-api-requests",children:"How External Data Sync Works (Not via API Requests)"}),"\n",(0,a.jsx)(s.p,{children:"Unlike the API flow we saw earlier, syncing external data typically happens through:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Standalone Scripts:"})," Programs that can be run manually or automatically by a scheduler."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Background Jobs:"})," Tasks that run in the background without blocking the main web server. (We'll cover how these are managed in the next chapter, ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/background_task_runner__bree__",children:"Background Task Runner (Bree)"}),")."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"These processes don't wait for an incoming HTTP request. Instead, they are triggered by a cron job, a manual command, or a background task runner."}),"\n",(0,a.jsxs)(s.p,{children:["Let's look at the scripts that initiate these sync operations. In the ",(0,a.jsx)(s.code,{children:"events-api"})," project, you'll find scripts in the ",(0,a.jsx)(s.code,{children:"bin"})," directory for this purpose."]}),"\n",(0,a.jsxs)(s.p,{children:["Here's a simplified look at ",(0,a.jsx)(s.code,{children:"bin/sync-untis-2-db.ts"}),", the script for syncing Untis data:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",children:"// Simplified bin\\sync-untis-2-db.ts\nimport { fetchUntis } from '../src/services/fetchUntis'; // Imports the function to fetch data from Untis\nimport { syncUntis2DB } from '../src/services/syncUntis2DB'; // Imports the function to process and update DB\n\n// This function runs when the script is executed\nconst main = async () => {\n    // ... code to get the date for syncing and find the semester ...\n    const semesterId = 'some-semester-id'; // Example\n    console.log('Starting Untis sync for semester', semesterId);\n\n    // 1. Fetch data from Untis\n    const untisData = await fetchUntis(semesterId); // Pass semester info\n\n    // 2. Process fetched data and update the database\n    await syncUntis2DB(semesterId, untisData);\n\n    console.log('Untis sync finished.');\n};\n\n// Execute the main function\nmain().catch((err) => console.error(err));\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Explanation:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["This is a simple Node.js script that can be run from the command line (e.g., ",(0,a.jsx)(s.code,{children:"yarn untis:sync 2023-01-01"}),")."]}),"\n",(0,a.jsxs)(s.li,{children:["It imports two main functions: ",(0,a.jsx)(s.code,{children:"fetchUntis"})," (responsible for communicating with the external Untis API) and ",(0,a.jsx)(s.code,{children:"syncUntis2DB"})," (responsible for taking the fetched data and updating our database)."]}),"\n",(0,a.jsxs)(s.li,{children:["The ",(0,a.jsx)(s.code,{children:"main"})," function orchestrates the process: first fetch, then sync to DB."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["There's also a similar script like ",(0,a.jsx)(s.code,{children:"bin/users-csv-to-db.ts"})," for importing data from files:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",children:"// Simplified bin\\users-csv-to-db.ts\nimport { parse } from 'csv-parse'; // Library to read CSV\nimport fs from 'fs';             // Node.js file system module\n// ... other imports ...\nimport prisma from '../src/prisma'; // Need Prisma to write to DB\n\n// Function to read, parse, and process the file\nconst processFile = async (filePath: string) => {\n    console.log('Processing file:', filePath);\n    const parser = fs.createReadStream(filePath).pipe(\n        parse({ /* ... csv options ... */ }) // Set up CSV parsing\n    );\n\n    parser.on('readable', async function () {\n        let record;\n        while ((record = parser.read()) !== null) {\n            // 1. Process each record from the file\n            console.log('Processing record:', record);\n            const userData = { /* ... map csv columns to user data ... */ };\n\n            // 2. Use Prisma to insert/update the data in the database\n            await prisma.user.upsert({\n                 where: { id: userData.id },\n                 update: userData,\n                 create: userData,\n            });\n            console.log('Upserted user:', userData.id);\n        }\n    });\n     await finished(parser);\n    console.log('Finished processing file:', filePath);\n};\n\n// Execute the function with file paths\nprocessFile(`${__dirname}/excel/gbsl-users.csv`).catch((err) => console.error(err));\n// processFile(`${__dirname}/excel/gbjb-users.csv`).catch((err) => console.error(err));\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Explanation:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["This script uses libraries (",(0,a.jsx)(s.code,{children:"csv-parse"}),", ",(0,a.jsx)(s.code,{children:"fs"}),") to read local CSV files."]}),"\n",(0,a.jsx)(s.li,{children:"It reads the file line by line (or record by record for CSV)."}),"\n",(0,a.jsxs)(s.li,{children:["For each record, it processes the data and then uses ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," (",(0,a.jsx)(s.code,{children:"prisma.user.upsert"}),") to update or insert the record into the database."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"These scripts illustrate that External Data Sync involves dedicated code paths that are separate from the API request handling flow."}),"\n",(0,a.jsx)(s.h2,{id:"under-the-hood-the-sync-process",children:"Under the Hood: The Sync Process"}),"\n",(0,a.jsxs)(s.p,{children:["Let's look closer at the Untis sync process (",(0,a.jsx)(s.code,{children:"fetchUntis"})," and ",(0,a.jsx)(s.code,{children:"syncUntis2DB"}),"). This is a two-step process: Fetching and then Syncing/Processing."]}),"\n",(0,a.jsxs)(s.h3,{id:"step-1-fetching-data-srcservicesfetchuntists",children:["Step 1: Fetching Data (",(0,a.jsx)(s.code,{children:"src\\services\\fetchUntis.ts"}),")"]}),"\n",(0,a.jsxs)(s.p,{children:['This module is responsible for communicating with the Untis API (the "other library"). It uses an external library (',(0,a.jsx)(s.code,{children:"webuntis"}),") to connect, authenticate, and request specific data (school years, teachers, classes, timetables)."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",children:"// Simplified src\\services\\fetchUntis.ts\nimport { WebUntisSecretAuth } from 'webuntis'; // Library for Untis API\nimport Logger from '../utils/logger';\n\n// Configure the Untis connection (uses environment variables for credentials)\nconst untis = new WebUntisSecretAuth(/* ... connection details ... */);\n\nexport interface UntisData {\n    schoolyear: any; // Simplified type\n    subjects: any[];\n    teachers: any[];\n    classes: any[];\n    timetable: any[];\n}\n\nexport const fetchUntis = async (semester: any): Promise<UntisData> => { // Simplified type for semester\n    Logger.info('Start fetching Untis Data');\n\n    await untis.login(); // Authenticate with Untis API\n    Logger.info('Login successful');\n\n    // --- Fetch data from Untis ---\n    const schoolyear = await untis.getSchoolyears(true); // Get school years\n    const subjects = await untis.getSubjects();         // Get subjects\n    const teachers = await untis.getTeachers();         // Get teachers\n    const classes = await untis.getClasses(true, schoolyear[0].id); // Get classes\n    // Needs to fetch timetable for each class/subject - this is more complex\n    const timetable = await untis.getTimetableForWeek(semester.untisSyncDate, /* ... params ...*/); // Get timetable\n\n\n    Logger.info('Finished fetching data');\n    await untis.logout(); // Log out from Untis API\n\n    return { schoolyear, subjects, teachers, classes, timetable }; // Return fetched data\n};\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Explanation:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["It initializes a connection object (",(0,a.jsx)(s.code,{children:"untis"}),") provided by the ",(0,a.jsx)(s.code,{children:"webuntis"})," library, using configuration details (like school name, username, secret, base URL) typically stored in environment variables for security."]}),"\n",(0,a.jsxs)(s.li,{children:["The ",(0,a.jsx)(s.code,{children:"fetchUntis"})," function performs a series of ",(0,a.jsx)(s.code,{children:"await untis....()"})," calls to retrieve different types of data from the Untis API."]}),"\n",(0,a.jsx)(s.li,{children:"It handles login and logout."}),"\n",(0,a.jsxs)(s.li,{children:["It returns a structured object containing all the fetched data (",(0,a.jsx)(s.code,{children:"UntisData"}),")."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["This ",(0,a.jsx)(s.code,{children:"fetchUntis"})," function is focused purely on ",(0,a.jsx)(s.em,{children:"getting"})," the data from the external source. It doesn't modify our database."]}),"\n",(0,a.jsxs)(s.h3,{id:"step-2-syncing-data-to-db-srcservicessyncuntis2dbts",children:["Step 2: Syncing Data to DB (",(0,a.jsx)(s.code,{children:"src\\services\\syncUntis2DB.ts"}),")"]}),"\n",(0,a.jsxs)(s.p,{children:["This module takes the data fetched by ",(0,a.jsx)(s.code,{children:"fetchUntis"}),", processes it, and updates our application's database using ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),'. This is where the "merge" happens.']}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",children:"// Simplified src\\services\\syncUntis2DB.ts\nimport type { Prisma, Semester } from '@prisma/client'; // Prisma types\nimport prisma from '../prisma'; // Our Prisma Client instance\nimport { UntisData } from './fetchUntis'; // Data structure from fetchUntis\nimport Logger from '../utils/logger';\n\nexport const syncUntis2DB = async (\n    semesterId: string,\n    data: UntisData // The data received from fetchUntis\n) => {\n    Logger.info('Start syncing Untis Data to DB');\n    const dbTransactions: Prisma.PrismaPromise<any>[] = []; // Collect database operations\n\n    // Example: Syncing Untis Classes\n    data.classes.forEach((untisClass) => {\n        // Logic to map Untis class data to our database structure, find departments, etc.\n        const processedClassData = {\n            id: untisClass.id,\n            name: untisClass.name, // Or a cleaned/mapped version\n            // ... other relevant fields ...\n            year: 2023, // Simplified - actual logic in code\n            department: { connect: { id: 'some-dep-id' } }, // Simplified\n        };\n\n        // Use Prisma's upsert to update if the class exists or create if it doesn't\n        const upsertClass = prisma.untisClass.upsert({\n            where: { id: processedClassData.id }, // Match based on Untis ID\n            update: processedClassData, // Data to update if found\n            create: processedClassData, // Data to create if not found\n        });\n        dbTransactions.push(upsertClass); // Add the operation to the transaction list\n    });\n\n    // Example: Syncing Untis Teachers\n    data.teachers.forEach((untisTeacher) => {\n        const processedTeacherData = {\n             id: untisTeacher.id,\n             name: untisTeacher.name,\n             longName: untisTeacher.longName,\n             // ... other fields ...\n             active: untisTeacher.active,\n        };\n         const upsertTeacher = prisma.untisTeacher.upsert({\n             where: { id: processedTeacherData.id },\n             update: processedTeacherData,\n             create: processedTeacherData,\n         });\n         dbTransactions.push(upsertTeacher);\n    });\n\n    // Example: Syncing Untis Timetable Lessons\n     // Note: Existing lessons for the semester might be deleted first\n    data.timetable.forEach((untisLesson) => {\n        // Logic to map Untis lesson data, find related classes/teachers, etc.\n        const processedLessonData = {\n            id: untisLesson.id,\n            room: untisLesson.rooms.map(r => r.element.name).join(', '),\n            subject: untisLesson.subjects[0]?.name || 'Unknown',\n            startTime: untisLesson.startTime,\n            endTime: untisLesson.endTime,\n            // ... other fields like date, weekday ...\n             semester: { connect: { id: semesterId } },\n             // Connect related classes and teachers using their IDs\n             classes: { connect: untisLesson.classes.map(c => ({ id: c.id })) }, // untis id -> our class id mapping happens here too\n             teachers: { connect: untisLesson.teachers.map(t => ({ id: t.id })) },\n        };\n         const upsertLesson = prisma.untisLesson.upsert({ // Usually lessons might entirely change, so delete+create or careful update logic might be needed.\n             where: { id: processedLessonData.id }, // Assuming Untis IDs are stable\n             update: processedLessonData,\n             create: processedLessonData,\n         });\n         dbTransactions.push(upsertLesson);\n    });\n\n\n    // Execute all collected database operations as a single transaction\n    Logger.info(`Executing ${dbTransactions.length} database transactions...`);\n    await prisma.$transaction(dbTransactions);\n    Logger.info('Untis sync to DB finished.');\n\n    // Returns a summary or success indicator\n};\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Explanation:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"syncUntis2DB"})," receives the fetched ",(0,a.jsx)(s.code,{children:"UntisData"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["It iterates through the lists of classes, teachers, timetable entries, etc., contained within the ",(0,a.jsx)(s.code,{children:"data"})," object."]}),"\n",(0,a.jsxs)(s.li,{children:["For each external data piece, it performs necessary ",(0,a.jsx)(s.strong,{children:"processing"})," (like mapping or cleaning names). This is where logic similar to what you might find in a ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Model"})," lives, but adapted for bulk import/sync. Example: Mapping legacy class names using ",(0,a.jsx)(s.code,{children:"mapLegacyClassName"})," (visible in the full snippet from ",(0,a.jsx)(s.code,{children:"src\\services\\importEvents.ts"}),") or finding the correct ",(0,a.jsx)(s.code,{children:"Department"})," based on class letters (",(0,a.jsx)(s.code,{children:"src\\services\\syncUntis2DB.ts"}),")."]}),"\n",(0,a.jsxs)(s.li,{children:["It uses ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," methods like ",(0,a.jsx)(s.code,{children:"upsert"})," (",(0,a.jsx)(s.code,{children:"update"})," or ",(0,a.jsx)(s.code,{children:"insert"}),") or potentially ",(0,a.jsx)(s.code,{children:"createMany"}),", ",(0,a.jsx)(s.code,{children:"deleteMany"}),", etc., to apply the changes to the database."]}),"\n",(0,a.jsxs)(s.li,{children:["Crucially, it collects all these individual database operations into an array (",(0,a.jsx)(s.code,{children:"dbTransactions"}),") and then executes them together using ",(0,a.jsx)(s.code,{children:"await prisma.$transaction(dbTransactions)"}),". This ensures that either ",(0,a.jsx)(s.em,{children:"all"})," the updates succeed, or if any part fails, ",(0,a.jsx)(s.em,{children:"none"})," of the changes are applied, keeping the database in a consistent state (a transaction)."]}),"\n",(0,a.jsxs)(s.li,{children:["Connecting related data (like linking a lesson to its classes and teachers) is also handled here using Prisma's ",(0,a.jsx)(s.code,{children:"connect"})," syntax."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["The logic for importing from CSV/Excel files (",(0,a.jsx)(s.code,{children:"src\\services\\importGBSL_xlsx.ts"}),", ",(0,a.jsx)(s.code,{children:"src\\services\\importGBJB_csv.ts"}),", ",(0,a.jsx)(s.code,{children:"src\\services\\importV1.ts"}),", ",(0,a.jsx)(s.code,{children:"src\\services\\importEvents.ts"}),") follows a similar pattern: read file -> parse rows -> process data -> use ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," (",(0,a.jsx)(s.code,{children:"create"})," or ",(0,a.jsx)(s.code,{children:"upsert"}),") to write to DB. The processing steps for files involve logic like extracting classes from raw text (",(0,a.jsx)(s.code,{children:"extractClasses"})," in ",(0,a.jsx)(s.code,{children:"src\\services\\importEvents.ts"}),") or mapping legacy department names (",(0,a.jsx)(s.code,{children:"mapLegacyClassName"}),", ",(0,a.jsx)(s.code,{children:"fromDisplayClassName"}),")."]}),"\n",(0,a.jsx)(s.h2,{id:"the-flow-of-external-data-sync",children:"The Flow of External Data Sync"}),"\n",(0,a.jsx)(s.p,{children:"Let's visualize the conceptual flow, showing that it's initiated differently from an API request."}),"\n",(0,a.jsx)(s.mermaid,{value:'sequenceDiagram\n    participant Trigger as Script/Scheduler (e.g., bin/sync-untis-2-db.ts)\n    participant ExternalSource as External System (Untis API or File)\n    participant DataProcessor as Data Fetch, Process & Sync Logic (Services)\n    participant PC as Prisma Client\n    participant DB as Database\n\n    Trigger->>DataProcessor: Initiate Sync (e.g., call fetchUntis)\n    DataProcessor->>ExternalSource: Request data (e.g., HTTP call to Untis API, Read file)\n    ExternalSource--\x3e>DataProcessor: Return raw external data\n    DataProcessor->>DataProcessor: Process/Cleanse data\n    DataProcessor->>PC: Perform DB operations (e.g., prisma.untisClass.upsert)\n    PC->>DB: Send SQL queries (e.g., INSERT/UPDATE "untis_classes")\n    DB--\x3e>PC: Return results\n    PC--\x3e>DataProcessor: Confirmation/Results\n    DataProcessor->>PC: Perform more DB ops (batch in transaction)\n    PC->>DB: Send SQL queries (e.g., $transaction)\n    DB--\x3e>PC: Return transaction result\n    PC--\x3e>DataProcessor: Transaction result\n    DataProcessor--\x3e>Trigger: Report success/failure/summary'}),"\n",(0,a.jsxs)(s.p,{children:["This diagram shows that the trigger starts the process, which directly interacts with the external source and then uses the Data Processor layer (our service functions like ",(0,a.jsx)(s.code,{children:"fetchUntis"})," and ",(0,a.jsx)(s.code,{children:"syncUntis2DB"}),") to handle the data transfer and synchronization with the database via ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),". The middleware/router/controller layers from the API flow are not involved here."]}),"\n",(0,a.jsx)(s.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(s.p,{children:["External Data Sync is a critical part of the ",(0,a.jsx)(s.code,{children:"events-api"}),", responsible for keeping our database updated with information from sources outside the application, like the Untis school system and legacy files. This happens through dedicated scripts and background processes that are separate from handling user-initiated API requests."]}),"\n",(0,a.jsxs)(s.p,{children:["This process involves fetching data from the external source (e.g., using ",(0,a.jsx)(s.code,{children:"fetchUntis"})," and external libraries or file system modules), processing and cleansing that data, and then using ",(0,a.jsx)(s.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," with functions like ",(0,a.jsx)(s.code,{children:"upsert"})," (often within a transaction) to synchronize the information into our database. These tasks are often scheduled to run automatically, which brings us to the next chapter: how we manage and run these tasks reliably in the background."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"/docs/dev/events-api/background_task_runner__bree__",children:"Next Chapter: Background Task Runner (Bree)"})}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:["Generated by ",(0,a.jsx)(s.a,{href:"https://github.com/The-Pocket/Tutorial-Codebase-Knowledge",children:"AI Codebase Knowledge Builder"})]})]})}function h(e={}){let{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},50065:function(e,s,t){t.d(s,{Z:()=>o,a:()=>i});var n=t(67294);let a={},r=n.createContext(a);function i(e){let s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);