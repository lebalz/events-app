"use strict";(self.webpackChunkevents_app=self.webpackChunkevents_app||[]).push([["9790"],{70723:function(e,t,r){r.r(t),r.d(t,{frontMatter:()=>o,default:()=>h,contentTitle:()=>i,assets:()=>d,toc:()=>c,metadata:()=>s});var s=JSON.parse('{"id":"dev/events-api/request_handlers__controllers__","title":"Chapter 5: Request Handlers (Controllers)","description":"Welcome back! In our last chapter, Access Control (Authentication & Authorization), we saw how our application uses the Express.js web server (API Web Server (Express.js)) and its middleware pipeline to receive requests, identify who is making the request (Authentication), and check if they are allowed to perform the requested action (Authorization).","source":"@site/docs/10-dev/events-api/05_request_handlers__controllers__.md","sourceDirName":"10-dev/events-api","slug":"/dev/events-api/request_handlers__controllers__","permalink":"/docs/dev/events-api/request_handlers__controllers__","draft":false,"unlisted":false,"editUrl":"https://github.com/lebalz/events-app/edit/main/10-dev/events-api/05_request_handlers__controllers__.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"page_id":"6bda5646-454b-40a3-a94d-20eee2b858f1"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Access Control (Authentication & Authorization)","permalink":"/docs/dev/events-api/access_control__authentication___authorization__"},"next":{"title":"Chapter 6: External Data Sync","permalink":"/docs/dev/events-api/external_data_sync_"}}'),n=r(85893),a=r(50065);let o={page_id:"6bda5646-454b-40a3-a94d-20eee2b858f1"},i="Chapter 5: Request Handlers (Controllers)",d={},c=[{value:"The Department Heads",id:"the-department-heads",level:2},{value:"Our Use Case: Handling the &quot;Create Event&quot; Request",id:"our-use-case-handling-the-create-event-request",level:2},{value:"Looking at an Example: <code>src\\controllers\\events.ts</code> <code>create</code> function",id:"looking-at-an-example-srccontrollerseventsts-create-function",level:2},{value:"What Happens Inside Other Controllers?",id:"what-happens-inside-other-controllers",level:2},{value:"The Flow with Request Handlers",id:"the-flow-with-request-handlers",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){let t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"chapter-5-request-handlers-controllers",children:"Chapter 5: Request Handlers (Controllers)"})}),"\n",(0,n.jsxs)(t.p,{children:["Welcome back! In our last chapter, ",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/access_control__authentication___authorization__",children:"Access Control (Authentication & Authorization)"}),", we saw how our application uses the Express.js web server (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),") and its middleware pipeline to receive requests, identify ",(0,n.jsx)(t.em,{children:"who"})," is making the request (Authentication), and check ",(0,n.jsx)(t.em,{children:"if"})," they are allowed to perform the requested action (Authorization)."]}),"\n",(0,n.jsxs)(t.p,{children:["So, a request comes in, Express receives it, middleware checks its validity and the user's permissions. What happens ",(0,n.jsx)(t.em,{children:"after"})," these checks pass? The request has been verified and is ready to be processed for its actual purpose \u2013 like getting a list of events or creating a new department."]}),"\n",(0,n.jsxs)(t.p,{children:["This is job of the ",(0,n.jsx)(t.strong,{children:"Request Handlers"}),", often referred to as ",(0,n.jsx)(t.strong,{children:"Controllers"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"the-department-heads",children:"The Department Heads"}),"\n",(0,n.jsx)(t.p,{children:"Let's return to our office building analogy."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"Express.js"})," is the Receptionist who receives all incoming visitors (requests)."]}),"\n",(0,n.jsxs)(t.li,{children:["Middleware (including ",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/access_control__authentication___authorization__",children:"Authentication & Authorization"}),") is the Security Guard who checks IDs and permissions at the entrance."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Models"}),' are the Expert Workers (like the "Event Expert" or "User Expert") who know how to deal with specific types of data and interact with the archive (',(0,n.jsx)(t.a,{href:"/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Who connects the approved visitors (requests) to the correct Expert Worker (Model) and makes sure the task gets done? That's the ",(0,n.jsx)(t.strong,{children:"Department Head"})," or ",(0,n.jsx)(t.strong,{children:"Manager"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In our ",(0,n.jsx)(t.code,{children:"events-api"}),", the ",(0,n.jsx)(t.strong,{children:"Request Handlers (Controllers)"})," are these managers. They are the specific functions that Express's router (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),") directs the request to once it knows ",(0,n.jsx)(t.em,{children:"what"})," the request is asking for and that the user is allowed to ask for it."]}),"\n",(0,n.jsx)(t.p,{children:"Their main job is to:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Receive"})," the incoming request (which has already passed authentication and authorization)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Understand"}),' the specific action needed (e.g., "find event by ID", "create new department").']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Delegate"})," the core task to the appropriate ",(0,n.jsx)(t.strong,{children:"Model"})," (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Data Logic (Models)"}),"), providing any necessary information from the request (like user ID, event data from the body, or a record ID from the URL)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Format"})," the result received back from the Model (or handle errors)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Send"})," the final response back to the client using the ",(0,n.jsx)(t.code,{children:"res"})," object."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"They don't contain the detailed business logic (that's the Models') nor do they handle infrastructural tasks like parsing JSON or checking auth (that's the middleware's). They are the conductors, orchestrating the flow for a specific request."}),"\n",(0,n.jsx)(t.h2,{id:"our-use-case-handling-the-create-event-request",children:'Our Use Case: Handling the "Create Event" Request'}),"\n",(0,n.jsxs)(t.p,{children:["Let's stick with our example from the previous chapter: ",(0,n.jsx)(t.strong,{children:"Creating a new event"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["We know that a ",(0,n.jsx)(t.code,{children:"POST"})," request to ",(0,n.jsx)(t.code,{children:"/api/v1/events"})," arrives, passes through middleware (logging, parsing, authentication, authorization), and is then matched by the Express router to a specific function. That function is the Controller function responsible for ",(0,n.jsx)(t.em,{children:"creating events"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Where do these functions live? They are organized in files within the ",(0,n.jsx)(t.code,{children:"src/controllers"})," directory, typically one file per major data type (e.g., ",(0,n.jsx)(t.code,{children:"src/controllers/events.ts"}),", ",(0,n.jsx)(t.code,{children:"src/controllers/users.ts"}),", ",(0,n.jsx)(t.code,{children:"src/controllers/departments.ts"}),")."]}),"\n",(0,n.jsxs)(t.p,{children:["In ",(0,n.jsx)(t.code,{children:"src/controllers/events.ts"}),", you'll find a function named ",(0,n.jsx)(t.code,{children:"create"}),". This is the function our router (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),") points to for incoming ",(0,n.jsx)(t.code,{children:"POST /events"})," requests."]}),"\n",(0,n.jsxs)(t.h2,{id:"looking-at-an-example-srccontrollerseventsts-create-function",children:["Looking at an Example: ",(0,n.jsx)(t.code,{children:"src\\controllers\\events.ts"})," ",(0,n.jsx)(t.code,{children:"create"})," function"]}),"\n",(0,n.jsxs)(t.p,{children:["Let's simplify the actual ",(0,n.jsx)(t.code,{children:"create"})," function from ",(0,n.jsx)(t.code,{children:"src/controllers/events.ts"})," to see its core structure:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"// Simplified src\\controllers\\events.ts - create function\r\nimport { RequestHandler } from 'express'; // Import Express type\r\n// ... other imports needed by the controller ...\r\nimport Events from '../models/event'; // Import the Events Model\r\n\r\n// This function handles POST requests to /api/v1/events\r\nexport const create: RequestHandler = async (req, res, next) => {\r\n    // 1. Get necessary data from the request\r\n    // The request body (req.body) contains the data for the new event.\r\n    // Middleware (like express.json) has already parsed this into a JS object.\r\n    const { start, end } = req.body;\r\n\r\n    // We know the user is authenticated and authorized because middleware ran before this!\r\n    // The authenticated user is available on req.user\r\n    const user = req.user!; // The '!' tells TypeScript user is definitely here\r\n\r\n    try {\r\n        // 2. Delegate the core task to the appropriate Model\r\n        // Call the createModel function on the Events Model, passing the user and event data.\r\n        const event = await Events.createModel(user, start, end);\r\n\r\n        // 3. & 4. Format and Send the response\r\n        // Set the HTTP status code to 201 (Created)\r\n        res.status(201);\r\n        // Send the created event object back as a JSON response\r\n        res.json(event);\r\n\r\n        // The actual code also adds notifications here for Socket.IO, which we'll cover later.\r\n        // res.notifications = [...];\r\n\r\n    } catch (e) {\r\n        // If any error occurs during the process (e.g., database error, Model validation error)\r\n        // Pass the error to the next middleware (our error handling middleware)\r\n        next(e);\r\n    }\r\n};\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Explanation:"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"export const create: RequestHandler = async (req, res, next) => { ... }"}),": This defines an asynchronous function named ",(0,n.jsx)(t.code,{children:"create"})," and types it as an Express ",(0,n.jsx)(t.code,{children:"RequestHandler"}),". ",(0,n.jsx)(t.code,{children:"RequestHandler"})," is a type definition provided by Express to clarify that this function expects three parameters: ",(0,n.jsx)(t.code,{children:"req"})," (the Request object), ",(0,n.jsx)(t.code,{children:"res"})," (the Response object), and ",(0,n.jsx)(t.code,{children:"next"})," (a function to call to pass control to the next middleware or error handler)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"const { start, end } = req.body;"}),": It accesses the ",(0,n.jsx)(t.code,{children:"body"})," of the incoming request (",(0,n.jsx)(t.code,{children:"req.body"}),"). Express middleware like ",(0,n.jsx)(t.code,{children:"express.json()"})," (which we saw in ",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),") automatically parses the JSON body of the request and makes it available as a JavaScript object here. We're extracting ",(0,n.jsx)(t.code,{children:"start"})," and ",(0,n.jsx)(t.code,{children:"end"})," date/time for the new event from this body."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"const user = req.user!;"}),": It accesses the ",(0,n.jsx)(t.code,{children:"user"})," object previously attached to the request by the ",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/access_control__authentication___authorization__",children:"Authentication & Authorization"})," middleware (specifically Passport). The Controller needs to know ",(0,n.jsx)(t.em,{children:"who"})," is creating the event, as this information is often required by the Model (e.g., to set the event's author)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"const event = await Events.createModel(user, start, end);"}),": ",(0,n.jsx)(t.strong,{children:"This is the core delegation step."})," The Controller doesn't contain the complex logic for inserting an event into the database or performing related actions. Instead, it calls the ",(0,n.jsx)(t.code,{children:"createModel"})," function on the ",(0,n.jsx)(t.code,{children:"Events"})," Model (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Data Logic (Models)"}),"). It passes the authenticated ",(0,n.jsx)(t.code,{children:"user"})," and the necessary event data (",(0,n.jsx)(t.code,{children:"start"}),", ",(0,n.jsx)(t.code,{children:"end"}),") to the Model. The ",(0,n.jsx)(t.code,{children:"await"})," keyword is used because creating data in the database takes time, and the Model function returns a Promise."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"res.status(201).json(event);"}),": If the Model successfully creates the event, the Controller receives the resulting event object back. It then uses the ",(0,n.jsx)(t.code,{children:"res"})," (Response) object to construct and send the final HTTP response:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"res.status(201)"}),' sets the HTTP status code to 201, which means "Created". This is the standard success code for resource creation.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"res.json(event)"})," formats the ",(0,n.jsx)(t.code,{children:"event"})," object into a JSON string and sends it back to the client."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"catch (e) { next(e); }"}),": This is standard Express error handling. If anything goes wrong within the ",(0,n.jsx)(t.code,{children:"try"})," block (e.g., the Model throws an error because the data was invalid, or a database connection fails), the ",(0,n.jsx)(t.code,{children:"catch"})," block catches the error and calls ",(0,n.jsx)(t.code,{children:"next(e)"}),". This passes the error down the middleware pipeline to Express's built-in error handler, or our custom error handling middleware, which will format an appropriate error response (like a 400 or 500 status code)."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["This simplified example demonstrates that the Controller for ",(0,n.jsx)(t.code,{children:"create"}),' acts as a thin layer that translates the incoming HTTP request (get data from body, identify user) into a clear instruction for the relevant Model ("create an event for this user with this start/end time").']}),"\n",(0,n.jsx)(t.h2,{id:"what-happens-inside-other-controllers",children:"What Happens Inside Other Controllers?"}),"\n",(0,n.jsx)(t.p,{children:"Controllers for other API endpoints follow a similar pattern:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"GET /api/v1/events"})," (all)"]}),": In ",(0,n.jsx)(t.code,{children:"src/controllers/events.ts"}),", the ",(0,n.jsx)(t.code,{children:"all"})," function likely calls ",(0,n.jsx)(t.code,{children:"Events.published()"})," or ",(0,n.jsx)(t.code,{children:"Events.all(req.user)"}),". It then sends the result using ",(0,n.jsx)(t.code,{children:"res.json()"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"GET /api/v1/events/:id"})," (find)"]}),": The ",(0,n.jsx)(t.code,{children:"find"})," function takes ",(0,n.jsx)(t.code,{children:":id"})," from ",(0,n.jsx)(t.code,{children:"req.params.id"}),", calls ",(0,n.jsx)(t.code,{children:"Events.findModel(req.user, req.params.id)"}),", and sends the found event via ",(0,n.jsx)(t.code,{children:"res.json()"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"PUT /api/v1/departments/:id"})," (update)"]}),": The ",(0,n.jsx)(t.code,{children:"update"})," function in ",(0,n.jsx)(t.code,{children:"src/controllers/departments.ts"})," gets the ID from ",(0,n.jsx)(t.code,{children:"req.params.id"}),", the update data from ",(0,n.jsx)(t.code,{children:"req.body.data"}),", calls ",(0,n.jsx)(t.code,{children:"Departments.updateModel(req.user!, req.params.id, req.body.data)"}),", and sends the updated department via ",(0,n.jsx)(t.code,{children:"res.json()"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"DELETE /api/v1/users/:id"})," (destroy)"]}),": The ",(0,n.jsx)(t.code,{children:"destroy"})," function in ",(0,n.jsx)(t.code,{children:"src/controllers/users.ts"})," gets the ID from ",(0,n.jsx)(t.code,{children:"req.params.id"}),", calls ",(0,n.jsx)(t.code,{children:"Users.destroy(req.user!, req.params.id)"}),", and typically sends a ",(0,n.jsx)(t.code,{children:"204 No Content"})," status back if successful (",(0,n.jsx)(t.code,{children:"res.status(204).send()"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["You can look at the other controller files (",(0,n.jsx)(t.code,{children:"src/controllers/*.ts"}),") linked in the code snippets section to see many more examples of this pattern. Each exported function in these files is a Request Handler (Controller) for a specific route registered in ",(0,n.jsx)(t.code,{children:"src/routes/router.ts"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"the-flow-with-request-handlers",children:"The Flow with Request Handlers"}),"\n",(0,n.jsxs)(t.p,{children:["Let's revisit the sequence diagram from the previous chapter, focusing on the Controller's place in the flow for our \"Create Event\" example (",(0,n.jsx)(t.code,{children:"POST /api/v1/events"}),"):"]}),"\n",(0,n.jsx)(t.mermaid,{value:"sequenceDiagram\r\n    participant Client as Browser/App\r\n    participant Server as Web Server (Express)\r\n    participant Middleware as Middleware (Auth, AuthZ, etc.)\r\n    participant Router as Express Router\r\n    participant Controller as Request Handler (createEvent)\r\n    participant Model as Data Logic (Events Model)\r\n    participant PC as Prisma Client\r\n    participant DB as Database\r\n\r\n    Client->>Server: POST /api/v1/events (with data)\r\n    Server->>Middleware: Pass Request/Response\r\n    Middleware->>Middleware: Process request (Log, Auth, AuthZ Pass)\r\n    Middleware->>Router: Call next(), Pass Request/Response\r\n    Router->>Controller: Match route, call handler (createEvent)\r\n    Controller->>Model: Delegate task, pass data (Events.createModel(user, data))\r\n    Model->>PC: Interact with DB (prisma.event.create...)\r\n    PC->>DB: Send SQL query (INSERT...)\r\n    DB--\x3e>PC: Return result\r\n    PC--\x3e>Model: Return JS Object\r\n    Model--\x3e>Controller: Return created object\r\n    Controller->>Server: Format & Send Response (res.status(201).json)\r\n    Server--\x3e>Client: Send 201 Created Response"}),"\n",(0,n.jsxs)(t.p,{children:["This diagram clearly shows the Controller receiving the request ",(0,n.jsx)(t.em,{children:"after"})," middleware and routing, then interacting with the Model to perform the actual data operation, and finally using the Server/Express to send the response back."]}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(t.p,{children:["Request Handlers or Controllers are the layer in our Express application responsible for the final step of processing an incoming request ",(0,n.jsx)(t.em,{children:"after"})," it has passed through authentication and authorization middleware. They are the specific functions mapped by the router to different API endpoints (URL path + HTTP method)."]}),"\n",(0,n.jsxs)(t.p,{children:["Their key role is to extract necessary information from the request (",(0,n.jsx)(t.code,{children:"req"}),"), delegate the core business logic to the appropriate Model (",(0,n.jsx)(t.a,{href:"/docs/dev/events-api/data_logic__models__",children:"Data Logic (Models)"}),"), handle the Model's response or any errors, and format the final HTTP response (",(0,n.jsx)(t.code,{children:"res"}),") to be sent back to the client. They act as the coordination point between the web server layer and the application's data logic layer."]}),"\n",(0,n.jsx)(t.p,{children:"We now have a solid understanding of how requests come into the API, get secured, and are then directed to specific code that uses our data Models and Prisma to interact with the database. But what about data that doesn't come directly from client requests? Our application also needs to get data from external systems automatically."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"/docs/dev/events-api/external_data_sync_",children:"Next Chapter: External Data Sync"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["Generated by ",(0,n.jsx)(t.a,{href:"https://github.com/The-Pocket/Tutorial-Codebase-Knowledge",children:"AI Codebase Knowledge Builder"})]})]})}function h(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},50065:function(e,t,r){r.d(t,{Z:()=>i,a:()=>o});var s=r(67294);let n={},a=s.createContext(n);function o(e){let t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);