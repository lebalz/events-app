"use strict";(self.webpackChunkevents_app=self.webpackChunkevents_app||[]).push([["6640"],{47854:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>o,default:()=>h,contentTitle:()=>a,assets:()=>c,toc:()=>d,metadata:()=>s});var s=JSON.parse('{"id":"dev/events-api/background_task_runner__bree__","title":"Chapter 7: Background Task Runner (Bree)","description":"Welcome back! In our last chapter, External Data Sync, we looked at how our events-api gets crucial data from outside sources like the Untis school system and legacy files through dedicated scripts, separate from the main web server request flow. These scripts handle tasks like fetching data periodically or importing large datasets.","source":"@site/docs/10-dev/events-api/07_background_task_runner__bree__.md","sourceDirName":"10-dev/events-api","slug":"/dev/events-api/background_task_runner__bree__","permalink":"/fr/docs/dev/events-api/background_task_runner__bree__","draft":false,"unlisted":false,"editUrl":"https://github.com/lebalz/events-app/edit/main/i18n/fr/docusaurus-plugin-content-docs/current/10-dev/events-api/07_background_task_runner__bree__.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"page_id":"bad7e181-8005-469d-930a-0ee909c6d605"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 6: External Data Sync","permalink":"/fr/docs/dev/events-api/external_data_sync_"},"next":{"title":"real_time_communication__socket_io__","permalink":"/fr/docs/dev/events-api/real_time_communication__socket_io__"}}'),i=r(85893),t=r(50065);let o={page_id:"bad7e181-8005-469d-930a-0ee909c6d605"},a="Chapter 7: Background Task Runner (Bree)",c={},d=[{value:"The Night Shift Crew",id:"the-night-shift-crew",level:2},{value:"Introducing Bree: Our Night Shift Foreman",id:"introducing-bree-our-night-shift-foreman",level:2},{value:"Our Use Case: Periodically Generating Calendar Files (<code>sync-ics</code>)",id:"our-use-case-periodically-generating-calendar-files-sync-ics",level:2},{value:"How Bree Manages the <code>sync-ics</code> Job",id:"how-bree-manages-the-sync-ics-job",level:2},{value:"1. Configuring Bree and Defining the Job (<code>src\\bree-runner.ts</code>)",id:"1-configuring-bree-and-defining-the-job-srcbree-runnerts",level:3},{value:"2. Writing the Job Script (<code>src\\jobs\\sync-ics.ts</code>)",id:"2-writing-the-job-script-srcjobssync-icsts",level:3},{value:"Under the Hood: Bree and Workers",id:"under-the-hood-bree-and-workers",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-7-background-task-runner-bree",children:"Chapter 7: Background Task Runner (Bree)"})}),"\n",(0,i.jsxs)(n.p,{children:["Welcome back! In our last chapter, ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/external_data_sync_",children:"External Data Sync"}),", we looked at how our ",(0,i.jsx)(n.code,{children:"events-api"})," gets crucial data from outside sources like the Untis school system and legacy files through dedicated scripts, separate from the main web server request flow. These scripts handle tasks like fetching data periodically or importing large datasets."]}),"\n",(0,i.jsx)(n.p,{children:"But how do we make sure these scripts run automatically at the right time (scheduled tasks) or run in the background without blocking anything else? For instance, syncing Untis data might need to happen every night, or generating hundreds of calendar files based on subscriptions could take a long time. We don't want these long-running or scheduled tasks to interfere with the main application's responsiveness when users make requests via the API."}),"\n",(0,i.jsx)(n.h2,{id:"the-night-shift-crew",children:"The Night Shift Crew"}),"\n",(0,i.jsxs)(n.p,{children:["Imagine our API application is like a bustling factory during the day, handling individual customer orders (user requests) quickly. The activities we discussed in previous chapters (",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/api_web_server__express_js__",children:"API Web Server (Express.js)"}),", ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/request_handlers__controllers__",children:"Request Handlers (Controllers)"}),", ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/data_logic__models__",children:"Data Logic (Models)"}),") are the day shift workers processing these orders immediately."]}),"\n",(0,i.jsx)(n.p,{children:'However, some tasks aren\'t tied to a specific incoming order, or they take too long to do while a customer waits. These tasks need a dedicated "night shift crew" that works in the background.'}),"\n",(0,i.jsx)(n.p,{children:"These background tasks include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scheduled Maintenance:"})," Like tidying up the database or performing regular backups (though not explicitly in this project's scope, it's a common example)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Periodic Reports/Generation:"})," Creating reports or files that are needed regularly (like generating calendar files for subscriptions)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Long-Running Processing:"})," Tasks that handle a large amount of data or take significant computation time (like syncing data from an external system if it's complex or involves fetching many things)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This is where a ",(0,i.jsx)(n.strong,{children:"Background Task Runner"})," comes in. It's like the supervisor who manages the night shift crew, telling them ",(0,i.jsx)(n.em,{children:"what"})," to do (",(0,i.jsx)(n.em,{children:"the job"}),") and ",(0,i.jsx)(n.em,{children:"when"})," to do it (",(0,i.jsx)(n.em,{children:"the schedule"}),"), ensuring they work independently without interrupting the day shift."]}),"\n",(0,i.jsx)(n.h2,{id:"introducing-bree-our-night-shift-foreman",children:"Introducing Bree: Our Night Shift Foreman"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.code,{children:"events-api"})," project, we use ",(0,i.jsx)(n.strong,{children:"Bree"})," as our background task runner. Bree is designed to run scheduled jobs in separate worker processes or threads. This is important because Node.js applications are typically single-threaded. If a single request handler or script runs a very long task, it blocks ",(0,i.jsx)(n.em,{children:"all"})," other requests and processing. By running jobs in separate workers, the main application thread remains free and responsive."]}),"\n",(0,i.jsx)(n.p,{children:"Think of Bree as the system that kicks off the night shift crew (the jobs) on their own separate machines so they don't take up space or resources on the main factory floor."}),"\n",(0,i.jsx)(n.p,{children:"Bree allows us to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Define Jobs:"})," Write the specific tasks we want to run in separate script files."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schedule Jobs:"})," Tell Bree ",(0,i.jsx)(n.em,{children:"when"}),' to run these jobs (e.g., "every night at 3 AM", "every 6 hours").']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Run Jobs Independently:"})," Bree starts these job scripts in dedicated worker threads or processes, isolating them from the main application server."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"our-use-case-periodically-generating-calendar-files-sync-ics",children:["Our Use Case: Periodically Generating Calendar Files (",(0,i.jsx)(n.code,{children:"sync-ics"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["A key feature of the ",(0,i.jsx)(n.code,{children:"events-api"})," is providing calendar subscriptions in ICS format. These ",(0,i.jsx)(n.code,{children:".ics"})," files allow users to subscribe to events in external calendar applications (like Google Calendar, Outlook, Apple Calendar). The content of these files needs to be generated based on the current data in our database."]}),"\n",(0,i.jsx)(n.p,{children:"Generating these files for potentially many users, classes, or departments can take time. Moreover, these files need to be updated periodically as events change or new data is synced from Untis. This task is perfect for a background job."}),"\n",(0,i.jsxs)(n.p,{children:["Our use case is: ",(0,i.jsx)(n.strong,{children:"Generate updated ICS calendar files for users, classes, and departments on a regular schedule."})]}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.code,{children:"events-api"}),", the task for this is called ",(0,i.jsx)(n.code,{children:"sync-ics"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"how-bree-manages-the-sync-ics-job",children:["How Bree Manages the ",(0,i.jsx)(n.code,{children:"sync-ics"})," Job"]}),"\n",(0,i.jsxs)(n.p,{children:["Let's see how Bree is configured to run the ",(0,i.jsx)(n.code,{children:"sync-ics"})," job."]}),"\n",(0,i.jsxs)(n.p,{children:["Bree's configuration is primarily done in ",(0,i.jsx)(n.code,{children:"src/bree-runner.ts"}),", and the actual job scripts live in the ",(0,i.jsx)(n.code,{children:"src/jobs"})," directory."]}),"\n",(0,i.jsxs)(n.h3,{id:"1-configuring-bree-and-defining-the-job-srcbree-runnerts",children:["1. Configuring Bree and Defining the Job (",(0,i.jsx)(n.code,{children:"src\\bree-runner.ts"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"This file initializes Bree and tells it which jobs to run and their schedules."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Simplified src\\bree-runner.ts\nimport Logger from './utils/logger'; // For logging\nimport Bree from 'bree'; // The Bree library\nimport path from 'path'; // Node.js path module\n\nif (process.env.NODE_ENV === 'production' || process.env.BREE) {\n    // Create a new Bree instance\n    const bree = new Bree({\n        logger: Logger, // Use our custom logger\n        root: path.join(__dirname, 'jobs'), // Tell Bree where to find job scripts (the 'jobs' directory)\n        jobs: [\n            // --- Define our 'sync-ics' job ---\n            {\n                name: 'sync-ics', // The name of the job, corresponds to the file name in 'src/jobs' (sync-ics.ts)\n                interval: 'every 6 hours', // How often to run the job\n                // This option runs the job once 20 seconds after Bree starts (useful for initial run)\n                // date: new Date(Date.now() + 20 * 1000)\n            }\n        ],\n        // This helps Bree find the job file correctly depending on if running raw TS or compiled JS\n        defaultExtension: process.env.TS_NODE ? 'ts' : 'js'\n    });\n\n    // Listen for Bree events (optional, for logging)\n    bree.on('worker created', (name) => { Logger.info(`Bree: worker created for ${name}`); });\n    bree.on('worker deleted', (name) => { Logger.info(`Bree: worker deleted for ${name}`); });\n    bree.on('worker started', (name) => { Logger.info(`Bree: worker started for ${name}`); }); // Custom log\n    bree.on('worker ended', (name) => { Logger.info(`Bree: worker ended for ${name}`); }); // Custom log\n    bree.on('worker error', (error, name) => { Logger.error(`Bree: worker error for ${name}`, error); }); // Custom log\n\n\n    // Start Bree! This checks the schedule and runs jobs when they are due.\n    bree.start();\n    Logger.info(`Bree started`); // Simplified log\n} else if (process.env.NODE_ENV !== 'test') {\n     // Log if Bree is not started in development mode\n    Logger.info(`Bree not started`); // Simplified log\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"new Bree(...)"}),": Creates an instance of the Bree job runner."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"root: path.join(__dirname, 'jobs')"}),": This tells Bree to look for job definition files (like ",(0,i.jsx)(n.code,{children:"sync-ics.ts"}),") inside the ",(0,i.jsx)(n.code,{children:"src/jobs"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"jobs: [ { name: 'sync-ics', interval: 'every 6 hours' } ]"}),": This is the crucial part that defines the ",(0,i.jsx)(n.code,{children:"sync-ics"})," job.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name: 'sync-ics'"}),": Bree will look for a file named ",(0,i.jsx)(n.code,{children:"sync-ics.ts"})," (or ",(0,i.jsx)(n.code,{children:"sync-ics.js"})," depending on the environment) in the ",(0,i.jsx)(n.code,{children:"root"})," directory. This file contains the actual code for the job."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interval: 'every 6 hours'"}),": This tells Bree to schedule this job to run approximately every 6 hours. Bree supports various scheduling options (cron syntax, milliseconds, dates, etc.)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"bree.start()"}),": This command kicks off the Bree scheduler. Bree will now periodically check the schedule for all defined jobs and run them when it's time."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This configuration ensures that the ",(0,i.jsx)(n.code,{children:"sync-ics.ts"})," script will be automatically executed by Bree every six hours."]}),"\n",(0,i.jsxs)(n.h3,{id:"2-writing-the-job-script-srcjobssync-icsts",children:["2. Writing the Job Script (",(0,i.jsx)(n.code,{children:"src\\jobs\\sync-ics.ts"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"This is the actual code that performs the task of generating ICS files. Bree runs this script in a separate worker thread/process."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Simplified src\\jobs\\sync-ics.ts\n// This script is executed by Bree in a separate worker\n\n// worker_threads allows communication with the parent process (Bree)\nimport { parentPort } from 'worker_threads';\nimport prisma from '../prisma'; // Our Prisma Client\nimport Users from '../models/user'; // Our Users Model\n// Services that contain the logic for creating ICS files\nimport { createIcsForClasses, createIcsForDepartments } from '../services/createIcs';\nimport Logger from '../utils/logger'; // Logger for the job\n\n// The job logic is inside an async immediately-invoked function expression (IIFE)\n(async () => {\n    Logger.info('sync-ics job started');\n    try {\n        // --- Task 1: Generate ICS for individual users ---\n        const usersWithUntisId = await prisma.user.findMany({\n             where: { untisId: { not: null } } // Only sync ICS for users linked to Untis\n        });\n        Logger.info(`Syncing ICS for ${usersWithUntisId.length} users...`);\n\n        // Loop through users and generate their ICS file\n        // The actual code processes in batches for performance\n        for (const user of usersWithUntisId) {\n             try {\n                // Call a function from the Users Model to create the ICS file for the user\n                await Users.createIcs(user, user.id);\n                 Logger.debug(`Created ics file for user ${user.id}`);\n             } catch (err) {\n                 Logger.warning(`Error creating ics for user ${user.id}: ${err}`);\n             }\n        }\n        Logger.info('Finished syncing user ICS files.');\n\n        // --- Task 2: Generate ICS for classes ---\n        // Call a service function to create ICS files for all classes\n        await createIcsForClasses();\n        Logger.info('Finished syncing class ICS files.');\n\n        // --- Task 3: Generate ICS for departments ---\n        // Call a service function to create ICS files for all departments\n        await createIcsForDepartments();\n        Logger.info('Finished syncing department ICS files.');\n\n\n        // Disconnect Prisma client when done in the worker\n        await prisma.$disconnect();\n        Logger.info('Prisma disconnected');\n\n        // --- Signal completion to Bree ---\n        // This is important for Bree to know the job ran successfully\n        if (parentPort) {\n            parentPort.postMessage('done');\n        } else {\n             // If running as a standalone script (not via Bree), exit manually\n            process.exit(0);\n        }\n\n    } catch (err) {\n        Logger.error('sync-ics job failed', err);\n        // Ensure Prisma is disconnected even on error\n         await prisma.$disconnect().catch(logError => Logger.error('Prisma disconnect failed after error', logError));\n        // --- Signal error to Bree ---\n        if (parentPort) {\n            parentPort.postMessage('error');\n        } else {\n            process.exit(1);\n        }\n    }\n})(); // Execute the async function immediately\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(async () => { ... })()"}),": The entire job logic is wrapped in an asynchronous immediately-invoked function. This allows using ",(0,i.jsx)(n.code,{children:"await"})," directly at the top level of the script."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"import prisma from '../prisma';"}),", ",(0,i.jsx)(n.code,{children:"import Users from '../models/user';"}),", ",(0,i.jsx)(n.code,{children:"import { createIcsForClasses, createIcsForDepartments } from '../services/createIcs';"}),": The job script imports the necessary components to perform its task \u2013 our ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," client to interact with the database, our ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/data_logic__models__",children:"Users Model"})," (which has the ",(0,i.jsx)(n.code,{children:"createIcs"})," function), and specific service functions responsible for the ICS generation logic (defined in ",(0,i.jsx)(n.code,{children:"src/services/createIcs.ts"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await prisma.user.findMany(...)"}),": The job script uses ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," to find all users who need an ICS file generated (users linked via ",(0,i.jsx)(n.code,{children:"untisId"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await Users.createIcs(user, user.id);"}),": It iterates through the users and calls a function from the ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/data_logic__models__",children:"Users Model"})," (",(0,i.jsx)(n.code,{children:"createIcs"}),") to handle the complex logic of fetching the user's relevant events and generating the ICS file. This function likely uses ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," internally to query events."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await createIcsForClasses()"})," and ",(0,i.jsx)(n.code,{children:"await createIcsForDepartments()"}),": These calls delegate the tasks of generating ICS files for classes and departments to dedicated service functions. These functions also interact with the database (via ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),") to fetch relevant events."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await prisma.$disconnect()"}),": It's good practice for job scripts that use Prisma to explicitly disconnect the Prisma client when the job is finished, freeing up database connections."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parentPort.postMessage('done');"}),": If the script is running in a worker thread managed by Bree (",(0,i.jsx)(n.code,{children:"parentPort"})," will exist), this line sends a message back to Bree indicating that the job completed successfully. Bree uses this to monitor the job status."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"catch (err) { ... parentPort.postMessage('error'); ... }"}),": Includes error handling. If any error occurs during the job execution, it's logged, Prisma is disconnected, and an 'error' message is sent back to Bree."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This script embodies the background task: it performs database reads (",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"}),", ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/data_logic__models__",children:"Models"}),"), calls data processing logic (services), and is designed to run independently without waiting for or responding to an HTTP request."]}),"\n",(0,i.jsx)(n.h2,{id:"under-the-hood-bree-and-workers",children:"Under the Hood: Bree and Workers"}),"\n",(0,i.jsxs)(n.p,{children:["Let's visualize how Bree runs a job like ",(0,i.jsx)(n.code,{children:"sync-ics"}),"."]}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant MainApp as Main Application (Express Server)\n    participant BreeRunner as Bree Orchestrator (in src/bree-runner.ts)\n    participant BreeWorker as Bree Worker Thread/Process\n    participant JobScript as Job Script (src/jobs/sync-ics.ts)\n    participant PC as Prisma Client\n    participant DB as Database\n\n    Note over MainApp, DB: Main App is running, serving API requests. Database is available.\n\n    MainApp->>BreeRunner: Initialize & Start Bree (when server starts)\n    BreeRunner->>BreeRunner: Check job schedules (e.g., time for 'sync-ics')\n    BreeRunner->>BreeWorker: Spin up new Worker Thread/Process for 'sync-ics'\n    BreeWorker->>JobScript: Execute src/jobs/sync-ics.ts within the worker\n    JobScript->>PC: Use Prisma Client (connects to DB)\n    loop Process Users, Classes, Departments\n        JobScript->>PC: Query DB (via Models/Services)\n        PC->>DB: Send SQL queries\n        DB--\x3e>PC: Return Data\n        PC--\x3e>JobScript: Return JS Objects\n        JobScript->>JobScript: Process data, Generate ICS files\n        JobScript->>PC: Update DB (e.g., save ICS file path)\n        PC->>DB: Send SQL queries (INSERT, UPDATE)\n        DB--\x3e>PC: Return status\n        PC--\x3e>JobScript: Confirmation\n    end\n    JobScript->>PC: Disconnect Prisma Client\n    PC--\x3e>JobScript: Disconnect confirmation\n    JobScript->>BreeWorker: Send 'done' or 'error' message (via parentPort)\n    BreeWorker--\x3e>BreeRunner: Job completed (status)\n    BreeRunner->>BreeRunner: Log job status, Clean up worker\n    Note over MainApp, DB: Main App continues serving requests uninterrupted."}),"\n",(0,i.jsx)(n.p,{children:"This diagram shows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Bree is initialized and started ",(0,i.jsx)(n.em,{children:"by"})," the main application but then runs independently in the background."]}),"\n",(0,i.jsxs)(n.li,{children:["When a job is due, Bree doesn't run it in the main application thread. Instead, it creates a ",(0,i.jsx)(n.em,{children:"separate"})," worker."]}),"\n",(0,i.jsxs)(n.li,{children:["The actual job script (",(0,i.jsx)(n.code,{children:"sync-ics.ts"}),") runs inside this dedicated worker."]}),"\n",(0,i.jsxs)(n.li,{children:["The job script interacts with ",(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," and the database directly from its worker process."]}),"\n",(0,i.jsxs)(n.li,{children:["Critically, the main application thread (handling Express requests) is ",(0,i.jsx)(n.em,{children:"not"})," blocked while the job script runs, even if the job takes a long time."]}),"\n",(0,i.jsx)(n.li,{children:"The worker communicates back to Bree when it's finished, allowing Bree to monitor and manage the jobs."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This isolation prevents long-running tasks like generating many ICS files from making the API unresponsive for users trying to fetch data or perform other quick actions."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["Using a background task runner like Bree is essential for handling tasks that need to run independently of user requests, either on a schedule or because they are long-running. In the ",(0,i.jsx)(n.code,{children:"events-api"}),", Bree manages jobs like ",(0,i.jsx)(n.code,{children:"sync-ics"}),", which periodically generates calendar files. Bree runs these jobs in separate worker processes or threads, ensuring that the main web server thread remains free to handle incoming API requests quickly and efficiently. By defining jobs in the ",(0,i.jsx)(n.code,{children:"src/jobs"})," directory and configuring their schedules in ",(0,i.jsx)(n.code,{children:"src/bree-runner.ts"}),", we offload heavy or time-sensitive tasks from the main application flow."]}),"\n",(0,i.jsxs)(n.p,{children:["We've now covered how the API handles incoming requests and interacts with data, as well as how it performs background tasks. But what about times when the server needs to send information ",(0,i.jsx)(n.em,{children:"to"})," a client ",(0,i.jsx)(n.em,{children:"without"})," the client having explicitly asked for it just then? This leads us to real-time communication."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/fr/docs/dev/events-api/real_time_communication__socket_io__",children:"Next Chapter: Real-time Communication (Socket.IO)"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Generated by ",(0,i.jsx)(n.a,{href:"https://github.com/The-Pocket/Tutorial-Codebase-Knowledge",children:"AI Codebase Knowledge Builder"})]})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},50065:function(e,n,r){r.d(n,{Z:()=>a,a:()=>o});var s=r(67294);let i={},t=s.createContext(i);function o(e){let n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);