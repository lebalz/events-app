"use strict";(self.webpackChunkevents_app=self.webpackChunkevents_app||[]).push([["112"],{95867:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>i,assets:()=>c,toc:()=>l,contentTitle:()=>a});var i=JSON.parse('{"id":"dev/events-api/notifications__email___socket_io__","title":"Chapter 9: Notifications (Email & Socket.IO)","description":"Welcome back! In our previous chapter, Real-time Communication (Socket.IO), we learned how our events-api uses Socket.IO to send instant updates to connected clients, like a live news ticker in a web app. This is great for showing changes right away on a user\'s screen.","source":"@site/docs/10-dev/events-api/09_notifications__email___socket_io__.md","sourceDirName":"10-dev/events-api","slug":"/dev/events-api/notifications__email___socket_io__","permalink":"/fr/docs/dev/events-api/notifications__email___socket_io__","draft":false,"unlisted":false,"editUrl":"https://github.com/lebalz/events-app/edit/main/i18n/fr/docusaurus-plugin-content-docs/current/10-dev/events-api/09_notifications__email___socket_io__.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"page_id":"1fc51a0e-9197-448c-97ec-b735547a03e3"},"sidebar":"tutorialSidebar","previous":{"title":"real_time_communication__socket_io__","permalink":"/fr/docs/dev/events-api/real_time_communication__socket_io__"},"next":{"title":"Mode d\'emploi FR","permalink":"/fr/docs/dev/guide-fr/"}}'),s=t("85893"),r=t("50065");let o={page_id:"1fc51a0e-9197-448c-97ec-b735547a03e3"},a="Chapter 9: Notifications (Email & Socket.IO)",c={},l=[{value:"Not Just a Ticker: A Multi-Channel Alert System",id:"not-just-a-ticker-a-multi-channel-alert-system",level:2},{value:"Our Use Case: Notifying Users When an Event is Deleted",id:"our-use-case-notifying-users-when-an-event-is-deleted",level:2},{value:"Triggering Notifications from the Controller",id:"triggering-notifications-from-the-controller",level:2},{value:"Sending Socket.IO Notifications (Recap)",id:"sending-socketio-notifications-recap",level:2},{value:"Sending Email Notifications",id:"sending-email-notifications",level:2},{value:"1. Identifying Recipients and Content Logic (<code>src\\services\\notifications\\notifyUsers.ts</code>)",id:"1-identifying-recipients-and-content-logic-srcservicesnotificationsnotifyusersts",level:3},{value:"2. Generating and Sending the Email (<code>src\\services\\notifications\\mail\\*.ts</code> and <code>authConfig.ts</code>)",id:"2-generating-and-sending-the-email-srcservicesnotificationsmailts-and-authconfigts",level:3},{value:"The Complete Notification Flow",id:"the-complete-notification-flow",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-9-notifications-email--socketio",children:"Chapter 9: Notifications (Email & Socket.IO)"})}),"\n",(0,s.jsxs)(n.p,{children:["Welcome back! In our previous chapter, ",(0,s.jsx)(n.a,{href:"/fr/docs/dev/events-api/real_time_communication__socket_io__",children:"Real-time Communication (Socket.IO)"}),", we learned how our ",(0,s.jsx)(n.code,{children:"events-api"})," uses Socket.IO to send instant updates to connected clients, like a live news ticker in a web app. This is great for showing changes right away on a user's screen."]}),"\n",(0,s.jsx)(n.p,{children:"But sometimes, an instant notification isn't enough, or the user might not be online or have the application open. What if an essential event they planned to attend is suddenly cancelled? They need to know about that crucial change reliably, even if they aren't actively looking at the app interface."}),"\n",(0,s.jsxs)(n.p,{children:["This is where a more comprehensive ",(0,s.jsx)(n.strong,{children:"Notification System"})," comes in. Its purpose is to inform users about important status changes, updates, or deletions related to events and other relevant data. It acts as the application's built-in communication manager, ensuring relevant people are alerted when something significant happens."]}),"\n",(0,s.jsx)(n.h2,{id:"not-just-a-ticker-a-multi-channel-alert-system",children:"Not Just a Ticker: A Multi-Channel Alert System"}),"\n",(0,s.jsxs)(n.p,{children:["Think of our application managing events. When an event is created, updated, or deleted, or when its review status changes (like from ",(0,s.jsx)(n.code,{children:"REVIEW"})," to ",(0,s.jsx)(n.code,{children:"PUBLISHED"})," or ",(0,s.jsx)(n.code,{children:"REFUSED"}),"), different users might need to be informed:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The event's author."}),"\n",(0,s.jsx)(n.li,{children:"Users who are affected by the event (e.g., students or teachers whose lessons are impacted)."}),"\n",(0,s.jsx)(n.li,{children:"Administrators who need to review events."}),"\n",(0,s.jsx)(n.li,{children:"Users who have subscribed to notifications about event changes."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The best way to reach these different users and provide the right level of detail often requires more than just an in-app message."}),"\n",(0,s.jsx)(n.p,{children:"Our notification system employs a dual approach:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Socket.IO Notifications:"})," For immediate, real-time updates within the connected application interface. This is like the live news ticker we discussed in the last chapter. It's ideal for showing a quick alert or updating a list dynamically."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Email Notifications:"})," For external, asynchronous, and often more detailed communication. This is like getting a specific alert email about a major news story. It ensures the user receives the information even if they are offline and provides a persistent record."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This dual strategy ensures that users are informed effectively, meeting both the need for instant feedback while using the app and reliable notification even when they aren't."}),"\n",(0,s.jsx)(n.h2,{id:"our-use-case-notifying-users-when-an-event-is-deleted",children:"Our Use Case: Notifying Users When an Event is Deleted"}),"\n",(0,s.jsx)(n.p,{children:"Let's consider the scenario where an administrator deletes a published event."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The connected web application needs to know immediately so it can remove the event from any lists the user is viewing."}),"\n",(0,s.jsx)(n.li,{children:"Users who were potentially affected by this event (e.g., those listed as attendees or whose timetable was impacted) should receive an email explaining that the event is cancelled."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This requires triggering ",(0,s.jsx)(n.em,{children:"both"})," a Socket.IO message ",(0,s.jsx)(n.em,{children:"and"})," targeted emails for the same underlying data change."]}),"\n",(0,s.jsx)(n.h2,{id:"triggering-notifications-from-the-controller",children:"Triggering Notifications from the Controller"}),"\n",(0,s.jsxs)(n.p,{children:["The notification process starts in the ",(0,s.jsx)(n.strong,{children:"Request Handlers (Controllers)"})," (",(0,s.jsx)(n.a,{href:"/fr/docs/dev/events-api/request_handlers__controllers__",children:"Request Handlers (Controllers)"}),"). After a Controller successfully performs an action that modifies data (like deleting an event via the Model), it decides which notifications are necessary."]}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"events-api"}),", Controllers handle this by:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Setting ",(0,s.jsx)(n.code,{children:"res.notifications"}),":"]})," Adding objects to this special property on the Express response to signal that Socket.IO notifications should be sent. This is primarily for real-time updates to connected clients."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Directly Calling Notification Services:"})," Invoking specific functions from notification service modules (like ",(0,s.jsx)(n.code,{children:"src/services/notifications/notifyUsers.ts"}),") to send emails."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's revisit a simplified example of the ",(0,s.jsx)(n.code,{children:"destroy"})," function in ",(0,s.jsx)(n.code,{children:"src/controllers/events.ts"})," and see how it triggers both:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Simplified snippet from src\\controllers\\events.ts - destroy function\r\nimport { RequestHandler } from 'express';\r\n// ... other imports ...\r\nimport Events from '../models/event'; // Import the Events Model\r\n// Import types for Socket.IO notifications\r\nimport { IoEvent, RecordType, Notification } from '../routes/socketEventTypes';\r\nimport { IoRoom } from '../routes/socketEvents'; // Import rooms\r\n// Import service function for email notifications\r\nimport { notifyOnDelete } from '../services/notifications/notifyUsers';\r\n\r\n\r\nconst NAME = RecordType.Event; // Define type of record for notifications\r\n\r\nexport const destroy: RequestHandler<{ id: string }> = async (req, res, next) => {\r\n    try {\r\n        // 1. Delegate the core task to the Model (deletes the event in the DB)\r\n        const deletedEvent = await Events.destroy(req.user!, req.params.id);\r\n\r\n        // Only send notifications for non-draft events that were actually deleted\r\n        if (deletedEvent.state !== 'DRAFT' && deletedEvent.deletedAt) {\r\n\r\n            // 2a. Add Socket.IO notification details to res.notifications\r\n            // This will trigger a real-time message to connected clients\r\n            res.notifications = [\r\n                { // This object tells the Socket.IO post-processor what to send\r\n                    message: { type: NAME, id: deletedEvent.id }, // Message payload: record type and ID\r\n                    event: IoEvent.DELETED_RECORD, // Socket.IO event type\r\n                    to: IoRoom.ALL // Send to all connected clients in the 'ALL' room\r\n                }\r\n            ];\r\n\r\n            // 2b. Directly call the email notification service\r\n            // This function handles identifying relevant users and sending emails\r\n            await notifyOnDelete(deletedEvent, req.user!);\r\n        }\r\n\r\n\r\n        // 3. Send the standard HTTP response\r\n        res.status(204).send(); // 204 No Content is typical for successful deletion\r\n\r\n    } catch (error) {\r\n        // Pass any errors to the error handling middleware\r\n        next(error);\r\n    }\r\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The controller calls ",(0,s.jsx)(n.code,{children:"Events.destroy"})," on the ",(0,s.jsx)(n.a,{href:"/fr/docs/dev/events-api/data_logic__models__",children:"Model"})," to perform the database operation."]}),"\n",(0,s.jsx)(n.li,{children:"After successful deletion, it checks if notifications are needed (i.e., if the deleted event wasn't a draft and is marked as deleted)."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"res.notifications = [...]"}),": An array is assigned to ",(0,s.jsx)(n.code,{children:"res.notifications"}),". This array contains objects structured according to the ",(0,s.jsx)(n.code,{children:"Notification"})," interface (defined in ",(0,s.jsx)(n.code,{children:"src/routes/socketEventTypes.ts"}),"). This specific notification object tells the system to emit a ",(0,s.jsx)(n.code,{children:"DELETED_RECORD"})," Socket.IO event with the event's type and ID, targeted at the ",(0,s.jsx)(n.code,{children:"IoRoom.ALL"})," (all connected clients)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"await notifyOnDelete(deletedEvent, req.user!);"}),": The controller directly calls the ",(0,s.jsx)(n.code,{children:"notifyOnDelete"})," function from ",(0,s.jsx)(n.code,{children:"src/services/notifications/notifyUsers.ts"}),". This function is specifically designed to handle the logic for sending emails when an event is deleted. It receives the details of the ",(0,s.jsx)(n.code,{children:"deletedEvent"})," and the ",(0,s.jsx)(n.code,{children:"actor"})," (the user who initiated the deletion) as arguments."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This split approach allows ",(0,s.jsx)(n.code,{children:"res.notifications"})," to act as a simple declaration for real-time events processed generically later, while dedicated email services (",(0,s.jsx)(n.code,{children:"notifyOnDelete"}),", ",(0,s.jsx)(n.code,{children:"notifyOnUpdate"}),", etc.) contain the complex logic needed for email recipients and content."]}),"\n",(0,s.jsx)(n.h2,{id:"sending-socketio-notifications-recap",children:"Sending Socket.IO Notifications (Recap)"}),"\n",(0,s.jsxs)(n.p,{children:["As covered in the ",(0,s.jsx)(n.a,{href:"/fr/docs/dev/events-api/real_time_communication__socket_io__",children:"Real-time Communication (Socket.IO)"})," chapter, a dedicated post-processing step (middleware or handler after the controller) looks for the ",(0,s.jsx)(n.code,{children:"res.notifications"})," property. If found, it iterates through the array and uses the ",(0,s.jsx)(n.code,{children:"io"})," instance (which was attached to ",(0,s.jsx)(n.code,{children:"req.io"})," in ",(0,s.jsx)(n.code,{children:"src/server.ts"}),") and helper functions (like ",(0,s.jsx)(n.code,{children:"notify"})," or ",(0,s.jsx)(n.code,{children:"notifyDeletedRecord"})," from ",(0,s.jsx)(n.code,{children:"src/routes/notify.ts"}),") to emit the specified Socket.IO events to the defined recipients (",(0,s.jsx)(n.code,{children:"to"})," field)."]}),"\n",(0,s.jsx)(n.p,{children:"This ensures that as soon as the HTTP request finishes processing (and before the final response is sent back), connected clients get the real-time updates."}),"\n",(0,s.jsx)(n.h2,{id:"sending-email-notifications",children:"Sending Email Notifications"}),"\n",(0,s.jsx)(n.p,{children:"Email notifications have a more complex flow because they involve external communication and require looking up user email addresses and potentially generating detailed content."}),"\n",(0,s.jsxs)(n.h3,{id:"1-identifying-recipients-and-content-logic-srcservicesnotificationsnotifyusersts",children:["1. Identifying Recipients and Content Logic (",(0,s.jsx)(n.code,{children:"src\\services\\notifications\\notifyUsers.ts"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["The service functions called directly by controllers (like ",(0,s.jsx)(n.code,{children:"notifyOnDelete"}),", ",(0,s.jsx)(n.code,{children:"notifyOnUpdate"}),", ",(0,s.jsx)(n.code,{children:"notifyOnReviewRequest"}),", ",(0,s.jsx)(n.code,{children:"notifyOnRefused"}),", ",(0,s.jsx)(n.code,{children:"mailOnAccept"})," - used within ",(0,s.jsx)(n.code,{children:"notifyOnUpdate"}),") contain the main logic for emails:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Who to email?"})," This involves querying the database to find relevant users based on factors like:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Are they marked to receive notifications (",(0,s.jsx)(n.code,{children:"notifyOnEventUpdate"})," field on ",(0,s.jsx)(n.code,{children:"User"})," model)?"]}),"\n",(0,s.jsxs)(n.li,{children:["Are they affected by the event change (using the ",(0,s.jsx)(n.code,{children:"view_AffectedByEvents"})," Prisma view, which links users/classes/departments to events)?"]}),"\n",(0,s.jsxs)(n.li,{children:["Are they administrators (based on ",(0,s.jsx)(n.code,{children:"Role"}),") and have enabled relevant admin notifications (",(0,s.jsx)(n.code,{children:"notifyAdminOnReviewRequest"}),", ",(0,s.jsx)(n.code,{children:"notifyAdminOnReviewDecision"}),")?"]}),"\n",(0,s.jsx)(n.li,{children:"Are they the author of the event?"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"What to email?"})," This logic determines the subject line, main message, and content of the email, often structured as a table of event details or changes. Different functions generate content tailored to deletion, update, acceptance, refusal, or review requests."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at a simplified snippet from ",(0,s.jsx)(n.code,{children:"src\\services\\notifications\\notifyUsers.ts"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Simplified snippet from src\\services\\notifications\\notifyUsers.ts - notifyOnDelete\r\nimport { EventState, User } from '@prisma/client';\r\nimport { ApiEvent } from '../../models/event.helpers';\r\nimport prisma from '../../prisma'; // Need Prisma to find affected users\r\n// Import specific email sending functions\r\nimport { mailOnDelete } from './mail/onDelete';\r\n// ... other imports and validMails fetching ...\r\n\r\nexport const notifyOnDelete = async (deleted: ApiEvent, actor: User) => {\r\n    // 1. Determine the audience (who needs this email?)\r\n    const affected = await prisma.view_AffectedByEvents.findMany({\r\n        where: {\r\n            eventId: deleted.id\r\n        },\r\n        select: {\r\n            userId: true // Get the IDs of users affected by the deleted event\r\n        },\r\n        distinct: ['userId'] // Ensure unique user IDs\r\n    });\r\n\r\n    // Get map of user IDs to emails for relevant locales\r\n    const validMails = await notifiableUsers(); // Function to fetch emails of users interested in notifications\r\n\r\n    // 2. Loop through relevant locales (de/fr in this case)\r\n    LOCALES.forEach((locale) => {\r\n        // 3. Filter affected user IDs to get their email addresses for this locale\r\n        const recipientEmails = affected\r\n            .map((e) => validMails[locale].get(e.userId)) // Get email for user ID, results in string | undefined\r\n            .filter((email): email is string => !!email); // Filter out undefined values\r\n\r\n        // 4. If there are recipients, call the specific mail sending function\r\n        if (recipientEmails.length > 0) {\r\n             mailOnDelete({ // Calls the function that creates and sends the 'deleted' email\r\n                 deleted: deleted, // Pass the deleted event\r\n                 actor: actor,     // Pass the user who deleted it\r\n                 to: recipientEmails, // List of email addresses\r\n                 locale: locale    // Language for the email\r\n             }); // Note: This is async, but often not awaited here to avoid blocking.\r\n        }\r\n    });\r\n};\r\n\r\n// --- Simplified notifyOnUpdate example ---\r\nexport const notifyOnUpdate = async (\r\n    events: { event: ApiEvent; previous?: ApiEvent; /* ... */ }[],\r\n    message: string, /* reason for refusal */\r\n    actor: User\r\n) => {\r\n     // ... complex logic here to find which users are newly affected, no longer affected, etc. ...\r\n     // ... uses prisma.view_AffectedByEvents and other queries ...\r\n\r\n      // Based on complex logic, build lists of recipients for different types of updates\r\n      // For example, send specific emails for:\r\n      // - Event accepted (to author, possibly affected users) -> calls mailOnAccept\r\n      // - Event refused (to author, admins) -> calls mailOnRefused\r\n      // - Event updated (to affected users who were and still are affected) -> calls mailOnChange with type AFFECTED\r\n      // - Event updated (to users newly affected) -> calls mailOnChange with type AFFECTED_NOW\r\n      // - Event updated (to users no longer affected) -> calls mailOnChange with type AFFECTED_PREVIOUS\r\n      // - Event sent for review (to admins) -> calls mailOnReviewRequest\r\n\r\n      // mailOnAccept, mailOnRefused, mailOnChange, mailOnReviewRequest are imported from './mail/*.ts'\r\n     // await mailOnAccept(...)\r\n     // await mailOnRefused(...)\r\n     // await mailOnChange(...)\r\n     // await mailOnChange(...)\r\n     // await mailOnChange(...)\r\n     // await mailOnReviewRequest(...)\r\n\r\n     // All these functions internally call sendMail\r\n};\r\n\r\n// ... other notification logic (e.g., notifyOnAccept, notifyOnRefused, notifyOnReviewRequest)...\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"notifyOnDelete"})," and ",(0,s.jsx)(n.code,{children:"notifyOnUpdate"})," and similar functions in ",(0,s.jsx)(n.code,{children:"src/services/notifications/notifyUsers.ts"})," are the central points for deciding ",(0,s.jsx)(n.em,{children:"who"})," gets an email and ",(0,s.jsx)(n.em,{children:"what type"})," of email based on the event change and the user base."]}),"\n",(0,s.jsxs)(n.li,{children:["They use ",(0,s.jsx)(n.a,{href:"/fr/docs/dev/events-api/database_orm__prisma__",children:"Prisma"})," (e.g., ",(0,s.jsx)(n.code,{children:"prisma.view_AffectedByEvents.findMany"}),") to query the database and find the relevant users."]}),"\n",(0,s.jsxs)(n.li,{children:["They fetch the email addresses for these users, often filtering based on language/locale and the user's notification preferences (",(0,s.jsx)(n.code,{children:"notifyOnEventUpdate"}),", ",(0,s.jsx)(n.code,{children:"notifyAdminOnReviewRequest"}),", etc.)."]}),"\n",(0,s.jsxs)(n.li,{children:["They then call specific email generation and sending functions (like ",(0,s.jsx)(n.code,{children:"mailOnDelete"}),", ",(0,s.jsx)(n.code,{children:"mailOnChange"}),", ",(0,s.jsx)(n.code,{children:"mailOnAccept"}),", etc., imported from ",(0,s.jsx)(n.code,{children:"src/services/notifications/mail/*.ts"}),"), passing the event details, the actor, recipient list, and locale."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-generating-and-sending-the-email-srcservicesnotificationsmailts-and-authconfigts",children:["2. Generating and Sending the Email (",(0,s.jsx)(n.code,{children:"src\\services\\notifications\\mail\\*.ts"})," and ",(0,s.jsx)(n.code,{children:"authConfig.ts"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["The functions in ",(0,s.jsx)(n.code,{children:"src/services/notifications/mail/"})," (like ",(0,s.jsx)(n.code,{children:"mailOnDelete.ts"}),", ",(0,s.jsx)(n.code,{children:"onChange.ts"}),", ",(0,s.jsx)(n.code,{children:"onAccepted.ts"}),", ",(0,s.jsx)(n.code,{children:"onRefused.ts"}),", ",(0,s.jsx)(n.code,{children:"onReviewRequest.ts"}),") are responsible for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Formatting the email content using libraries like ",(0,s.jsx)(n.code,{children:"mailgen"})," to create structured HTML emails."]}),"\n",(0,s.jsx)(n.li,{children:"Defining the subject line, intro text, and tabular data summarizing the event details or changes."}),"\n",(0,s.jsxs)(n.li,{children:["Calling the low-level mail sending function (",(0,s.jsx)(n.code,{children:"sendMail"}),") with the complete email configuration (sender, recipients, subject, HTML/text body)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"sendMail"})," function in ",(0,s.jsx)(n.code,{children:"src\\services\\notifications\\mail\\authConfig.ts"})," handles the actual interaction with an external SMTP server (the service that delivers emails) using Nodeemailer:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Simplified snippet from src\\services\\notifications\\mail\\authConfig.ts\r\nimport { createTransport } from 'nodemailer'; // Library for sending emails\r\nimport Mail from 'nodemailer/lib/mailer'; // Nodemailer types\r\nimport SMTPTransport from 'nodemailer/lib/smtp-transport'; // SMTP transport types\r\n\r\n// Configuration for connecting to the email server (uses environment variables)\r\nexport const authConfig: Readonly<SMTPTransport.Options> = Object.freeze({\r\n    service: 'edubern365', // Example service name\r\n    host: process.env.MAIL_HOST || '', // Email server address\r\n    // ... other connection details and credentials securely stored in env vars ...\r\n    auth: Object.freeze({\r\n        user: process.env.MAIL_USERNAME || '',\r\n        pass: process.env.MAIL_PASSWORD || ''\r\n    })\r\n});\r\n\r\nexport const sendMail = async (config: Mail.Options) => {\r\n    if (process.env.NODE_ENV === 'test' /* || !process.env.MAIL_HOST */) {\r\n        // In test/dev without config, simulate success without sending\r\n        console.log('Simulating email send:', config.subject, 'to:', config.to || config.bcc || 'N/A');\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    // 1. Create a Nodemailer transporter instance using the authConfig\r\n    const transporter = createTransport(authConfig);\r\n\r\n    // 2. Send the email using the configured transporter and the provided content config\r\n    return transporter.sendMail(config)\r\n        .then((info) => {\r\n            // Log success information\r\n            console.log('Email sent:', info.response);\r\n            return true;\r\n        })\r\n        .catch((err) => {\r\n            // Log and handle errors during sending\r\n            console.error('Error sending email:', err);\r\n            return false;\r\n        });\r\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"authConfig"})," object holds the credentials and server details for connecting to the email sending service, loaded from environment variables for security."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createTransport(authConfig)"}),' creates a "transporter" object, configured with the server details.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transporter.sendMail(config)"})," takes the email content configuration (sender, recipients, subject, body, etc.) and attempts to send the email through the external SMTP server."]}),"\n",(0,s.jsx)(n.li,{children:"The function handles promises to manage the asynchronous sending process and includes basic logging and error handling."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The email-specific service functions (",(0,s.jsx)(n.code,{children:"mailOnDelete"}),", etc.) in ",(0,s.jsx)(n.code,{children:"src/services/notifications/mail/"})," use ",(0,s.jsx)(n.code,{children:"mailgen"})," to generate the HTML and plain text body and then call this ",(0,s.jsx)(n.code,{children:"sendMail"})," function with the compiled content."]}),"\n",(0,s.jsx)(n.h2,{id:"the-complete-notification-flow",children:"The Complete Notification Flow"}),"\n",(0,s.jsx)(n.p,{children:"Let's visualize the end-to-end notification flow when an administrator deletes a published event."}),"\n",(0,s.jsx)(n.mermaid,{value:" secuenciaDiagram\r\n    participant Client Admin as Admin Browser App\r\n    participant WS_HTTP as Web Server (Express HTTP)\r\n    participant Middleware as Middleware (Auth, AuthZ, JSON, etc.)\r\n    participant Router as Express Router\r\n    participant Controller as Event Controller (destroy)\r\n    participant Model as Event Model\r\n    participant PC as Prisma Client\r\n    participant DB as Database\r\n    participant NotificationHandler as Socket.IO Post-Processor\r\n    participant SIO_WS as Socket.IO Server\r\n    participant SIO_Client Affected as Affected User Socket.IO Client\r\n    participant EmailService as Email Service (notifyUsers.ts/mail/*.ts)\r\n    participant SmtpServer as External SMTP Server\r\n    participant UserMailbox as Affected User Mailbox\r\n\r\n    Client Admin->>WS_HTTP: 1. HTTP DELETE /api/v1/events/:id\r\n    WS_HTTP->>Middleware: 2. Pass Request/Response\r\n    Middleware->>Router: 3. Process Request (Auth, AuthZ Pass)\r\n    Router->>Controller: 4. Match route, Call destroy controller\r\n    Controller->>Model: 5. Delegate Deletion (Events.destroy)\r\n    Model->>PC: 6. Delete Record (prisma.event.update soft-delete)\r\n    PC->>DB: 7. Send SQL (UPDATE ... SET deletedAt=...)\r\n    DB--\x3e>PC: 8. Return Deleted Record\r\n    PC--\x3e>Model: 9. Return Deleted Event Object\r\n    Model--\x3e>Controller: 10. Return Deleted Event Object\r\n    Controller->>Controller: 11a. Add Socket.IO Notification to res.notifications (deleted event ID, to:ALL)\r\n    Controller->>EmailService: 11b. Call notifyOnDelete(deletedEvent, req.user!)\r\n    EmailService->>PC: 12. Query Database (view_AffectedByEvents to find recipients)\r\n    PC->>DB: 13. Send SQL (SELECT ... FROM \"view_AffectedByEvents\" ...)\r\n    DB--\x3e>PC: 14. Return Affected User IDs\r\n    PC--\x3e>EmailService: 15. Return Affected User IDs\r\n    EmailService->>EmailService: 16. Fetch user emails, Generate email content (call mailOnDelete)\r\n    EmailService->>SmtpServer: 17. Send Email (via sendMail & Nodemailer)\r\n    SmtpServer->>UserMailbox: 18. Deliver Email\r\n\r\n    Controller--\x3e>NotificationHandler: 19. Response handed to Socket.IO post-processor\r\n    NotificationHandler->>SIO_WS: 20. Access io from req.io, Call notifyDeletedRecord(io, ...)\r\n    SIO_WS->>SIO_WS: 21. Use .to(IoRoom.ALL) to target all clients\r\n    SIO_WS->>SIO_Client Affected: 22. Emit 'DELETED_RECORD' event over socket\r\n    Note right of SIO_Client Affected: UI updates based on received event\r\n\r\n    NotificationHandler--\x3e>WS_HTTP: 23. Finalize HTTP response\r\n    WS_HTTP--\x3e>Client Admin: 24. HTTP 204 No Content (Standard response to Admin's DELETE)\r\n"}),"\n",(0,s.jsx)(n.p,{children:"This diagram illustrates the dual path notifications take:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The standard HTTP request triggers the change."}),"\n",(0,s.jsxs)(n.li,{children:["The Controller initiates ",(0,s.jsx)(n.em,{children:"both"})," the Socket.IO notification (by setting ",(0,s.jsx)(n.code,{children:"res.notifications"}),") and the Email notification (by directly calling an email service function)."]}),"\n",(0,s.jsx)(n.li,{children:"The Socket.IO notification is picked up by a separate post-processor and sent via the persistent Socket.IO connections to connected clients."}),"\n",(0,s.jsx)(n.li,{children:"The Email service function finds recipients by querying the DB and then sends the email through an external SMTP server."}),"\n",(0,s.jsx)(n.li,{children:"Both notification types happen concurrently after the database change, ensuring prompt in-app updates and reliable external communication via email."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"events-api"})," provides a robust notification system by combining the speed of real-time Socket.IO messages with the reliability and detail of email. Controllers act as the trigger points, initiating both types of notifications immediately after a significant data change is successfully committed. Socket.IO updates are handled via the ",(0,s.jsx)(n.code,{children:"res.notifications"})," property and a post-processing step, providing instant feedback to connected users. Email notifications are managed by calling dedicated service functions (like those in ",(0,s.jsx)(n.code,{children:"src/services/notifications/notifyUsers.ts"}),") directly from the Controller; these services are responsible for identifying the correct email recipients and generating detailed email content using helper functions and an external mail sending transporter. This multi-channel approach ensures that users are effectively informed about changes that matter to them, supporting a responsive and reliable event management system."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Generated by ",(0,s.jsx)(n.a,{href:"https://github.com/The-Pocket/Tutorial-Codebase-Knowledge",children:"AI Codebase Knowledge Builder"})]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return o}});var i=t(67294);let s={},r=i.createContext(s);function o(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);